# 开发者使用教程

## 概述

本教程为开发者提供完整的更新模块使用指南，包括日常开发工作流、版本发布流程、故障排除等。更新模块采用配置驱动设计，开发者只需专注于业务逻辑开发，版本管理变得极其简单。

## 快速开始

### 日常开发工作流

#### 1. 专注业务开发
开发者可以专注于业务逻辑开发，无需关心更新功能的维护：

```python
# 开发新功能
def new_pdf_processing_feature():
    # 您的业务逻辑代码
    pass

# 测试功能
def test_feature():
    # 测试代码
    pass
```

#### 2. 版本发布（只需一步）
开发完成后，只需修改配置文件中的版本号：

```json
{
  "version": {
    "current": "2.1.0"  // 从 2.0.0 改为 2.1.0
  }
}
```

就这么简单！所有版本相关信息会自动同步。

## 版本管理最佳实践

### 版本号命名规范

推荐使用语义化版本号（Semantic Versioning）：

```
主版本.次版本.修订版本
```

**示例**：
- `1.0.0` - 第一个稳定版本
- `1.1.0` - 新增功能，向后兼容
- `1.1.1` - 修复bug，向后兼容
- `2.0.0` - 重大更改，可能不兼容

### 版本发布流程

#### 步骤1：开发完成
```bash
# 提交业务代码
git add .
git commit -m "feat: 添加新的PDF处理功能"
```

#### 步骤2：更新版本号
编辑 `updater_config.json`：
```json
{
  "version": {
    "current": "2.1.0"
  }
}
```

#### 步骤3：提交版本更新
```bash
git add updater_config.json
git commit -m "release: v2.1.0"
```

#### 步骤4：创建GitHub Release
```bash
# 创建并推送标签
git tag v2.1.0
git push origin v2.1.0

# 使用GitHub CLI创建Release
gh release create v2.1.0 \
  --title "版本2.1.0发布" \
  --notes "新增功能：
- 改进PDF文本提取算法
- 优化批量处理性能
- 修复已知bug" \
  YourAppName-2.1.0.exe
```

### 版本提交信息规范

使用Conventional Commits格式：

```bash
# 新功能
git commit -m "feat: 添加批量处理功能"

# 修复bug
git commit -m "fix: 修复版本号解析错误"

# 文档更新
git commit -m "docs: 更新配置文件说明"

# 版本发布
git commit -m "release: v2.1.0"
```

## 配置文件管理

### 日常配置维护

开发者无需经常修改配置文件，只需要在以下情况时进行修改：

#### 1. 发布新版本时
```json
{
  "version": {
    "current": "2.1.0"  // 更新为新版本号
  }
}
```

#### 2. 更换GitHub仓库时
```json
{
  "repository": {
    "owner": "new-username",
    "repo": "new-repo-name"
  }
}
```

#### 3. 调整更新策略时
```json
{
  "update": {
    "check_interval_days": 7,    // 改为每周检查
    "backup_count": 5,           // 保留5个备份
    "download_timeout": 600      // 下载超时10分钟
  }
}
```

### 配置验证

开发者可以验证配置是否正确：

```python
def validate_updater_config():
    """验证更新配置"""
    from auto_updater.config import get_config

    try:
        config = get_config()

        # 检查关键配置
        print(f"✅ 应用名称: {config.app_name}")
        print(f"✅ 当前版本: {config.current_version}")
        print(f"✅ GitHub仓库: {config.github_repo}")
        print(f"✅ 检查间隔: {config.update_check_interval_days}天")

        return True

    except Exception as e:
        print(f"❌ 配置验证失败: {e}")
        return False

# 使用示例
if validate_updater_config():
    print("配置验证通过，可以继续开发")
else:
    print("配置存在问题，请检查updater_config.json")
```

## 更新功能集成

### 新项目集成

如果要在新项目中集成更新功能：

#### 步骤1：复制模块
```bash
# 从现有项目复制更新模块
cp -r /path/to/existing/auto_updater /path/to/new/project/

# 复制配置模板
cp /path/to/existing/updater_config.json.template /path/to/new/project/updater_config.json
```

#### 步骤2：修改配置
编辑 `updater_config.json`：
```json
{
  "app": {
    "name": "你的应用名称",
    "executable": "YourApp.exe"
  },
  "repository": {
    "owner": "your-username",
    "repo": "your-updates-repo"
  },
  "version": {
    "current": "1.0.0"
  }
}
```

#### 步骤3：集成代码
```python
import sys
sys.path.append('auto_updater')

from auto_updater import AutoUpdater

class YourMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # 初始化更新器
        self.auto_updater = AutoUpdater(self)

        # 设置UI
        self.setup_ui()

    def setup_ui(self):
        # 添加更新菜单
        update_action = QAction("检查更新", self)
        update_action.triggered.connect(self.check_for_updates)
        self.menuBar().addAction(update_action)

    def check_for_updates(self):
        has_update, remote_version, local_version, error = self.auto_updater.check_for_updates()
        # 处理更新逻辑...
```

### 现有项目升级

如果现有项目已经有旧版更新功能，升级到配置驱动版本：

#### 步骤1：备份现有配置
```bash
# 备份现有配置
cp update_config.json update_config.json.backup
```

#### 步骤2：替换配置文件
```json
// 旧配置格式
{
  "github_repo": "user/repo",
  "current_version": "1.0.0",
  // ...
}

// 新配置格式
{
  "app": {
    "name": "应用名称",
    "executable": "app.exe"
  },
  "repository": {
    "owner": "user",
    "repo": "repo"
  },
  "version": {
    "current": "1.0.0"
  }
}
```

## 测试和调试

### 本地测试更新功能

#### 模拟更新测试
```python
def test_update_functionality():
    """测试更新功能"""
    from auto_updater import AutoUpdater

    updater = AutoUpdater()

    # 测试配置读取
    config = updater.version_manager._config
    print(f"当前版本: {config.get('version', {}).get('current')}")

    # 测试版本检查（不强制检查）
    has_update, remote_version, local_version, error = updater.check_for_updates(force_check=False)

    if error:
        print(f"检查更新失败: {error}")
    else:
        print(f"本地版本: {local_version}")
        print(f"远程版本: {remote_version}")
        print(f"有更新: {has_update}")

# 运行测试
test_update_functionality()
```

#### 模拟下载测试
```python
def test_download_functionality():
    """测试下载功能"""
    from auto_updater import AutoUpdater

    updater = AutoUpdater()

    def progress_callback(downloaded, total, percentage):
        print(f"下载进度: {percentage}%")

    # 测试下载（使用测试版本）
    success, file_path, error = updater.download_update("1.0.0", progress_callback)

    if success:
        print(f"下载成功: {file_path}")
    else:
        print(f"下载失败: {error}")

# 注意：这会实际下载文件，仅用于测试
# test_download_functionality()
```

### 调试模式

启用详细日志记录：

```python
import logging

# 设置日志级别
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# 现在所有操作都会记录详细日志
updater = AutoUpdater()
```

### 常见问题调试

#### 1. 配置文件无法读取
```python
def debug_config_loading():
    """调试配置加载"""
    import json
    import os

    config_path = "updater_config.json"

    print(f"配置文件路径: {os.path.abspath(config_path)}")
    print(f"文件是否存在: {os.path.exists(config_path)}")

    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            print("配置文件格式正确")
            print(f"配置内容: {config}")
        except json.JSONDecodeError as e:
            print(f"JSON格式错误: {e}")
        except Exception as e:
            print(f"读取错误: {e}")
    else:
        print("配置文件不存在")

debug_config_loading()
```

#### 2. GitHub API访问问题
```python
def debug_github_access():
    """调试GitHub API访问"""
    from auto_updater.config import get_config

    config = get_config()

    print(f"GitHub仓库: {config.github_repo}")
    print(f"API基础URL: {config.github_api_base}")

    # 测试API连接
    import requests

    url = f"{config.github_api_base}/repos/{config.github_repo}/releases/latest"
    try:
        response = requests.get(url, timeout=10)
        print(f"API状态码: {response.status_code}")

        if response.status_code == 200:
            data = response.json()
            print(f"最新版本: {data.get('tag_name')}")
        else:
            print(f"API错误: {response.text}")
    except Exception as e:
        print(f"网络错误: {e}")

debug_github_access()
```

## 发布流程自动化

### 自动化脚本示例

创建 `release.py` 脚本自动化发布流程：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
自动化发布脚本
"""

import json
import subprocess
import sys
import os

def update_version(new_version):
    """更新版本号"""
    config_path = "updater_config.json"

    with open(config_path, 'r', encoding='utf-8') as f:
        config = json.load(f)

    old_version = config['version']['current']
    config['version']['current'] = new_version

    with open(config_path, 'w', encoding='utf-8') as f:
        json.dump(config, f, indent=2, ensure_ascii=False)

    print(f"版本号已更新: {old_version} → {new_version}")

def commit_changes(version):
    """提交更改"""
    subprocess.run(["git", "add", "updater_config.json"], check=True)
    subprocess.run(["git", "commit", "-m", f"release: v{version}"], check=True)
    print(f"代码已提交: v{version}")

def create_tag_and_release(version):
    """创建标签和Release"""
    subprocess.run(["git", "tag", f"v{version}"], check=True)
    subprocess.run(["git", "push", "origin", f"v{version}"], check=True)

    # 使用GitHub CLI创建Release
    result = subprocess.run([
        "gh", "release", "create", f"v{version}",
        "--title", f"版本{version}发布",
        "--notes", f"版本{version}的发布说明"
    ], capture_output=True, text=True)

    if result.returncode == 0:
        print(f"Release已创建: v{version}")
    else:
        print(f"Release创建失败: {result.stderr}")

def main():
    """主函数"""
    if len(sys.argv) != 2:
        print("用法: python release.py <版本号>")
        print("示例: python release.py 2.1.0")
        sys.exit(1)

    version = sys.argv[1]

    # 验证版本号格式
    import re
    if not re.match(r'^\d+\.\d+(\.\d+)?$', version):
        print(f"错误: 无效的版本号格式: {version}")
        sys.exit(1)

    print(f"开始发布版本: {version}")

    try:
        update_version(version)
        commit_changes(version)
        create_tag_and_release(version)
        print(f"✅ 发布完成: v{version}")
    except Exception as e:
        print(f"❌ 发布失败: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### 使用自动化脚本
```bash
# 发布新版本
python release.py 2.1.0

# 输出示例:
# 版本号已更新: 2.0.0 → 2.1.0
# 代码已提交: v2.1.0
# Release已创建: v2.1.0
# ✅ 发布完成: v2.1.0
```

## 故障排除

### 常见问题及解决方案

#### 1. 更新检查失败
**症状**：点击"检查更新"后提示失败
**可能原因**：
- 网络连接问题
- GitHub仓库配置错误
- API访问限制

**解决方案**：
```python
# 检查网络连接
import requests
try:
    response = requests.get("https://api.github.com", timeout=5)
    print("网络连接正常")
except Exception as e:
    print(f"网络连接失败: {e}")

# 检查配置文件
from auto_updater.config import get_config
config = get_config()
print(f"仓库配置: {config.github_repo}")
```

#### 2. 下载失败
**症状**：下载进度条不动或失败
**可能原因**：
- Release文件不存在
- 下载链接错误
- 磁盘空间不足

**解决方案**：
```python
# 检查Release文件
from auto_updater.github_client import GitHubClient
client = GitHubClient()
release = client.get_latest_release()

if release:
    assets = release.get('assets', [])
    print(f"可用文件: {[asset['name'] for asset in assets]}")
else:
    print("未找到Release信息")
```

#### 3. 更新后无法启动
**症状**：更新完成后应用程序无法启动
**可能原因**：
- 更新文件损坏
- 权限问题
- 依赖缺失

**解决方案**：
```python
# 检查文件完整性
import os
import hashlib

def verify_file_integrity(file_path, expected_size=None):
    """验证文件完整性"""
    if not os.path.exists(file_path):
        return False, "文件不存在"

    size = os.path.getsize(file_path)
    if expected_size and size != expected_size:
        return False, f"文件大小不匹配: {size} vs {expected_size}"

    # 计算文件哈希
    with open(file_path, 'rb') as f:
        file_hash = hashlib.md5(f.read()).hexdigest()

    return True, f"文件完整性验证通过 (MD5: {file_hash})"

# 使用示例
result, message = verify_file_integrity("YourApp.exe")
print(message)
```

## 开发者最佳实践

### 1. 版本管理
- 使用语义化版本号
- 及时更新配置文件
- 保持发布说明的完整性

### 2. 测试策略
- 在测试环境中验证更新功能
- 使用不同的网络条件测试
- 测试异常情况的处理

### 3. 文档维护
- 更新用户文档
- 记录重要的版本变更
- 维护故障排除指南

### 4. 监控和维护
- 监控更新成功率
- 分析用户反馈
- 定期检查GitHub仓库状态

## 总结

通过配置驱动的设计，开发者可以：

1. **专注业务开发** - 无需关心更新功能的内部实现
2. **简化版本发布** - 只需修改配置文件中的一个版本号
3. **自动化流程** - 使用脚本自动化发布流程
4. **快速集成** - 新项目可以快速集成更新功能

更新模块的设计理念就是让开发者从复杂的版本管理工作中解放出来，专注于创造更好的业务价值。